#!/usr/bin/env ruby
# encoding: utf-8

require 'twitter_ebooks'
require 'ostruct'

module Ebooks::Util
  def pretty_exception(e)

  end
end

module Ebooks::CLI
  APP_PATH = Dir.pwd # XXX do some recursive thing instead
  HELP = OpenStruct.new

  HELP.default = <<STR
Usage:
     ebooks help <command>

     ebooks new <reponame>
     ebooks s[tart]
     ebooks c[onsole]
     ebooks auth
     ebooks consume <corpus_path> [corpus_path2] [...]
     ebooks consume-all <corpus_path> [corpus_path2] [...]
     ebooks gen <model_path> [input]
     ebooks archive <username> [path]
     ebooks tweet <model_path> <botname>
STR

  def self.help(command=nil)
    if command.nil?
      log HELP.default
    else
      log HELP[command].gsub(/^ {4}/, '')
    end
  end

  HELP.new = <<-STR
    Usage: ebooks new <reponame>

    Creates a new skeleton repository defining a template bot in
    the current working directory specified by <reponame>.
  STR

  def self.new(reponame)
    if reponame.nil?
      help :new
      exit 1
    end

    path = "./#{reponame}"

    if File.exists?(path)
      log "#{path} already exists. Please remove if you want to recreate."
      exit 1
    end

    FileUtils.cp_r(Ebooks::SKELETON_PATH, path)
    FileUtils.mv(File.join(path, 'gitignore'), File.join(path, '.gitignore'))

    File.open(File.join(path, 'bots.rb'), 'w') do |f|
      template = File.read(File.join(Ebooks::SKELETON_PATH, 'bots.rb'))
      f.write(template.gsub("{{BOT_NAME}}", reponame))
    end

    File.open(File.join(path, 'Gemfile'), 'w') do |f|
      template = File.read(File.join(Ebooks::SKELETON_PATH, 'Gemfile'))
      f.write(template.gsub("{{RUBY_VERSION}}", RUBY_VERSION))
    end

    log "New twitter_ebooks app created at #{reponame}"
  end

  HELP.consume = <<-STR
    Usage: ebooks consume <corpus_path> [corpus_path2] [...]

    Processes some number of text files or json tweet corpuses
    into usable models. These will be output at model/<name>.model
  STR

  def self.consume(pathes)
    if pathes.empty?
      help :consume
      exit 1
    end

    pathes.each do |path|
      filename = File.basename(path)
      shortname = filename.split('.')[0..-2].join('.')

      outpath = File.join(APP_PATH, 'model', "#{shortname}.model")
      Ebooks::Model.consume(path).save(outpath)
      log "Corpus consumed to #{outpath}"
    end
  end

  HELP.consume_all = <<-STR
    Usage: ebooks consume-all <name> <corpus_path> [corpus_path2] [...]

    Processes some number of text files or json tweet corpuses
    into one usable model. It will be output at model/<name>.model
  STR

  def self.consume_all(name, paths)
    if paths.empty?
      help :consume_all
      exit 1
    end

    outpath = File.join(APP_PATH, 'model', "#{name}.model")
    Ebooks::Model.consume_all(paths).save(outpath)
    log "Corpuses consumed to #{outpath}"
  end

  HELP.gen = <<-STR
    Usage: ebooks gen <model_path> [input]

    Make a test tweet from the processed model at <model_path>.
    Will respond to input if provided.
  STR

  def self.gen(model_path, input)
    if model_path.nil?
      help :gen
      exit 1
    end

    model = Ebooks::Model.load(model_path)
    if input && !input.empty?
      puts "@cmd " + model.make_response(input, 135)
    else
      puts model.make_statement
    end
  end

  HELP.archive = <<-STR
    Usage: ebooks archive <username> [outpath]

    Downloads a json corpus of the <username>'s tweets.
    Output defaults to corpus/<username>.json
    Due to API limitations, this can only receive up to ~3000 tweets
    into the past.
  STR

  def self.archive(username, outpath=nil)
    if username.nil?
      help :archive
      exit 1
    end

    Ebooks::Archive.new(username, outpath).sync
  end

  HELP.tweet = <<-STR
    Usage: ebooks tweet <model_path> <botname>

    Sends a public tweet from the specified bot using text
    from the processed model at <model_path>.
  STR

  def self.tweet(modelpath, botname)
    if modelpath.nil? || botname.nil?
      help :tweet
      exit 1
    end

    load File.join(APP_PATH, 'bots.rb')
    model = Ebooks::Model.load(modelpath)
    statement = model.make_statement
    bot = Ebooks::Bot.get(botname)
    bot.configure
    bot.tweet(statement)
  end

  HELP.auth = <<-STR
    Usage: ebooks auth

    Authenticates your Twitter app for any account. By default, will
    use the consumer key and secret from the first defined bot. You
    can specify another by setting the CONSUMER_KEY and CONSUMER_SECRET
    environment variables.
  STR

  def self.auth
    consumer_key, consumer_secret = find_consumer
    require 'oauth'

    consumer = OAuth::Consumer.new(
      consumer_key,
      consumer_secret,
      site: 'https://twitter.com/',
      scheme: :header
    )

    request_token = consumer.get_request_token
    auth_url = request_token.authorize_url()

    pin = nil
    loop do
      log auth_url

      log "Go to the above url and follow the prompts, then enter the PIN code here."
      print "> "

      pin = STDIN.gets.chomp

      break unless pin.empty?
    end

    access_token = request_token.get_access_token(oauth_verifier: pin)
    token_username = access_token.params['screen_name']

    if fill_access_token token_username, access_token.token, access_token.secret
      log "Please check that @#{token_username}'s details have been updated in bots.rb correctly."
    else
      log "@#{token_username} authorized successfully. Make sure to put these in your bots.rb!"
    end
    log "  access token: #{access_token.token}\n" +
        "  access token secret: #{access_token.secret}"
  end

  HELP.console = <<-STR
    Usage: ebooks c[onsole]

    Starts an interactive ruby session with your bots loaded
    and configured.
  STR

  def self.console
    load_bots
    require 'pry'; Ebooks.module_exec { pry }
  end

  HELP.start = <<-STR
    Usage: ebooks s[tart] [botname]

    Starts running bots. If botname is provided, only runs that bot.
  STR

  def self.start(botname=nil)
    load_bots

    if botname.nil?
      bots = Ebooks::Bot.all
    else
      bots = Ebooks::Bot.all.select { |bot| bot.username == botname }
      if bots.empty?
        log "Couldn't find a defined bot for @#{botname}!"
        exit 1
      end
    end

    threads = []
    bots.each do |bot|
      threads << Thread.new { bot.prepare }
    end
    threads.each(&:join)

    threads = []
    bots.each do |bot|
      threads << Thread.new do
        loop do
          begin
            bot.start
          rescue Exception => e
            bot.log e.inspect
            puts e.backtrace.map { |s| "\t"+s }.join("\n")
          end
          bot.log "Sleeping before reconnect"
          sleep 5
        end
      end
    end
    threads.each(&:join)
  end

  # Non-command methods

  def self.find_consumer
    if ENV['CONSUMER_KEY'] && ENV['CONSUMER_SECRET']
      log "Using consumer details from environment variables:\n" +
          "  consumer key: #{ENV['CONSUMER_KEY']}\n" +
          "  consumer secret: #{ENV['CONSUMER_SECRET']}"
      return [ENV['CONSUMER_KEY'], ENV['CONSUMER_SECRET']]
    end

    load_bots
    consumer_key = nil
    consumer_secret = nil
    Ebooks::Bot.all.each do |bot|
      if bot.consumer_key && bot.consumer_secret
        consumer_key = bot.consumer_key
        consumer_secret = bot.consumer_secret
        log "Using consumer details from @#{bot.username}:\n" +
            "  consumer key: #{bot.consumer_key}\n" +
            "  consumer secret: #{bot.consumer_secret}\n"
        return consumer_key, consumer_secret
      end
    end

    if consumer_key.nil? || consumer_secret.nil?
      log "Couldn't find any consumer details to auth an account with.\n" +
          "Please either configure a bot with consumer_key and consumer_secret\n" +
          "or provide the CONSUMER_KEY and CONSUMER_SECRET environment variables."
      exit 1
    end
  end

  def self.load_bots
    load 'bots.rb'

    if Ebooks::Bot.all.empty?
      puts "Couldn't find any bots! Please make sure bots.rb instantiates at least one bot."
    end
  end

  def self.fill_access_token(username, access_token, access_token_secret)
    # This keeps track of what we're doing.
    stage = :looking_for_bot
    # This is used to hold onto the user's bot variable later.
    bot_variable = ''
    # This holds the last bot class we found. Only used if normal bot detection fails.
    bot_class = ''
    # This will be passed out to File.write later.
    output = ''
    # This keeps track of whether we can tell the user we succeeded or not.
    replaced_token = false
    replaced_secret = false
    # Process each line of bots.rb
    File.foreach 'bots.rb' do |line|
      # Strip out all whitespace to make matching easier.
      stripped_line = line.gsub /\s+/, ''
      # Drop comments if they exist.
      stripped_line.gsub! /#[^"']*$/, ''
      case stage
      when :looking_for_bot
        # Matches default bot declarations, with an optional # comment at the end or a @ before their name.
        if stripped_line.match /^\w+\.new\(?(["'])(@?)#{Regexp.escape username}\1\)?do\|(\w+)\|$/
          # Store the variable they're using for their bot.
          bot_variable = $3
          # Help them out if they put a @ in front of their bot's username
          if $2 == '@'
            # It's safe to do another regex here because we don't use the last one's $ variables anymore.
            line = line.gsub /(["'])@(#{Regexp.escape username})\1/, "\\1\\2\\1"
          end
          # Switch to next stage
          stage = :replacing_access_tokens
        end
        # Add current line to output.
        output += line
      when :replacing_access_tokens
        # Find out if we're looking at an access_token_line
        case stripped_line
        # Empty access token line
        when /^#{Regexp.escape bot_variable}\.access_token=(["'])\1$/
          # Replace pairs of quotes containing only spaces with the same type of quote containing token.
          output += line.gsub /(['"])\s*\1/, "\\1#{access_token}\\1"
          replaced_token = true
        # Empty access token secret line
        when /^#{Regexp.escape bot_variable}\.access_token_secret=(["'])\1$/
          # Replace pairs of quotes containing only spaces with the same type of quote containing token secret.
          output += line.gsub /(['"])\s*\1/, "\\1#{access_token_secret}\\1"
          replaced_secret = true
        # Another bot definition
        when /^\w+\.new\(?["'](@?)\w*["']\)?do\|(\w+)\|$/
          # This file is either nonstandard or something weird happened. Have the user manually edit it.
          return false
        # End of bot definition
        when /^end$/
          # Remember that we saw an end.
          stage = :done
          output += line
        # Other lines
        else
          output += line
        end
      when :done
        # We're outside of bot definition now, so just copy the rest.
        output += line
      end

      # Also try to detect user's last defined bot class
      if stripped_line.match /class(\w+)<Ebooks::Bot/
        bot_class = $1
      end
    end

    # Were we unable to find our bot at all?
    if stage == :looking_for_bot
      # We can't do anything if we didn't detect a class definiton either.
      return false if bot_class.empty?

      # Generate a new bot definition.
      output += <<-PuddiDOC.gsub /^ {6}/, ''

      # Make a #{bot_class} and attach it to an account
      #{bot_class}.new('#{username}') do |bot|
        bot.access_token = '#{access_token}' # Token connecting the app to this account
        bot.access_token_secret = '#{access_token_secret}' # Secret connecting the app to this account
      end
      PuddiDOC

      # Well, now we're pretty much done.
      stage = :done
      replaced_token = true
      replaced_secret = true
    end

    # Don't do anything if stage isn't done, because it means something weird happened or the user's bots.rb is non-standard.
    return false unless stage == :done

    # Is there any point in replacing file?
    if replaced_token || replaced_secret
      # Replace it.
      File.open 'bots.rb', 'w' do |file|
        file.write output
      end
    end

    # Did we replace both lines successfully?
    replaced_token && replaced_secret
  rescue
    # The file is probably unavailable for reading, so user will have to manually input.
    false
  end

  def self.command(args)
    if args.length == 0
      help
      exit 1
    end

    case args[0]
    when "new" then new(args[1])
    when "consume" then consume(args[1..-1])
    when "consume-all" then consume_all(args[1], args[2..-1])
    when "gen" then gen(args[1], args[2..-1].join(' '))
    when "archive" then archive(args[1], args[2])
    when "tweet" then tweet(args[1], args[2])
    when "jsonify" then jsonify(args[1..-1])
    when "auth" then auth
    when "console" then console
    when "c" then console
    when "start" then start(args[1])
    when "s" then start(args[1])
    when "help" then help(args[1])
    else
      log "No such command '#{args[0]}'"
      help
      exit 1
    end
  end
end

Ebooks::CLI.command(ARGV)
